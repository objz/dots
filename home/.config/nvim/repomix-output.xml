This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
lua/
  config/
    autocmds.lua
    dap.lua
    java.lua
    lazy.lua
    mappings.lua
    rust.lua
    theme.lua
  plugins/
    autosplit.lua
    blink.lua
    bufferline.lua
    conform.lua
    dap-view.lua
    dap.lua
    fff.lua
    goto_preview.lua
    icons.lua
    lazygit.lua
    lualine.lua
    markdown.lua
    mason.lua
    multiterm.lua
    no_conf.lua
    noice.lua
    snacks.lua
    telescope.lua
    treesitter.lua
    urlpreview.lua
    which_key.lua
scripts/
  nvid_helper.sh
  nvid_launcher.sh
init.lua
lazy-lock.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lua/config/autocmds.lua">
-- Highlight on yank
local highlight_group = vim.api.nvim_create_augroup("YankHighlight", { clear = true })
vim.api.nvim_create_autocmd("TextYankPost", {
	pattern = "*",
	callback = function()
		vim.highlight.on_yank()
	end,
	group = highlight_group,
})

vim.filetype.add({
	extension = {
		zsh = "sh",
		sh = "sh",
	},
	filename = {
		[".zshrc"] = "sh",
		["zshrc"] = "sh",
		[".zshenv"] = "sh",
	},
})

vim.api.nvim_create_autocmd("FileType", {
	pattern = "java",
	callback = function(args)
		local bufnr = args.buf

		for _, client in pairs(vim.lsp.get_clients({ bufnr = bufnr })) do
			if client.name == "jdtls" then
				return
			end
		end

		local java_conf = require("config.java").get_config()
		if not java_conf then
			return
		end

		require("jdtls").start_or_attach(java_conf)
	end,
})

local group = vim.api.nvim_create_augroup("UserRustLsp", { clear = true })
vim.api.nvim_create_autocmd("FileType", {
	group = group,
	pattern = { "rust" },
	callback = function(args)
		local lspconfig = require("lspconfig")
		local cfg = require("config.rust").get_config()
		if not cfg then return end
		if not lspconfig.rust_analyzer.manager then
			lspconfig.rust_analyzer.setup(cfg)
		end
		lspconfig.rust_analyzer.manager.try_add(args.buf)
	end,
})

vim.api.nvim_create_autocmd("LspAttach", {
	callback = function(args)
		local client = vim.lsp.get_client_by_id(args.data.client_id)
		if client.name ~= "jdtls" then
			return
		end

		local bufnr = args.buf
		require("which-key").add({
			{ "<leader>co", "<cmd>lua require'jdtls'.organize_imports()<cr>",     desc = "[JDTLS] Organize Imports" },
			{ "<leader>cs", "<cmd>lua require'jdtls'.super_implementation()<cr>", desc = "[JDTLS] Super Implementation" },
			{ "<leader>r",  group = "Run Configurations" },
			{ "<leader>rd", "<cmd>9Multiterm ./gradlew dev<cr>",                  desc = "gradlew dev" },
			{ "<leader>rb", "<cmd>9Multiterm ./gradlew build<cr>",                desc = "gradlew build" },
			{ "<leader>rs", "<cmd>9Multiterm ./gradlew shadowJar<cr>",            desc = "gradlew shadowJar" },
			{ "<leader>rm", "<cmd>9Multiterm ./gradlew modrinth<cr>",             desc = "gradlew modrinth" },
		}, { buffer = bufnr })
	end,
})


vim.api.nvim_create_autocmd("LspAttach", {
	callback = function(args)
		local client = vim.lsp.get_client_by_id(args.data.client_id)
		if client.name ~= "rust_analyzer" then
			return
		end

		local bufnr = args.buf
		require("which-key").add({
			{ "<leader>r",  group = "Run Configurations" },
			{ "<leader>rd", "<cmd>9Multiterm cargo build<cr>",  desc = "cargo build" },
			{ "<leader>rb", "<cmd>9Multiterm cargo run<cr>",    desc = "cargo run" },
			{ "<leader>rs", "<cmd>9Multiterm cargo test<cr>",   desc = "cargo test" },
			{ "<leader>rm", "<cmd>9Multiterm cargo update<cr>", desc = "cargo update" },
		}, { buffer = bufnr })
	end,
})



-- vim.api.nvim_create_autocmd("LspAttach", {
-- 	callback = function(args)
-- 		pcall(vim.api.nvim_buf_del_keymap, args.buf, "n", "K")
-- 	end,
-- })

-- vim.api.nvim_create_autocmd({ "BufEnter", "BufWritePost" }, {
-- 	callback = function()
-- 		vim.defer_fn(function()
-- 			for _, client in pairs(vim.lsp.get_clients({ bufnr = 0 })) do
-- 				if client.server_capabilities.codeLensProvider then
-- 					vim.lsp.codelens.refresh()
-- 					return
-- 				end
-- 			end
-- 		end, 100)
-- 	end,
-- })


-- Command aliases for common typos
vim.api.nvim_create_user_command("Qa", "qa", {})
vim.api.nvim_create_user_command("QA", "qa", {})
vim.api.nvim_create_user_command("Qall", "qall", {})
vim.api.nvim_create_user_command("QAll", "qall", {})
vim.api.nvim_create_user_command("QALL", "qall", {})
vim.api.nvim_create_user_command("W", "w", {})
vim.api.nvim_create_user_command("Wq", "wq", {})
vim.api.nvim_create_user_command("WQ", "wq", {})
vim.api.nvim_create_user_command("Wqa", "wqa", {})
vim.api.nvim_create_user_command("WQa", "wqa", {})
vim.api.nvim_create_user_command("WQA", "wqa", {})


-- fix blink coloshemes

local function fix_blink_highlights()
	vim.api.nvim_set_hl(0, "BlinkCmpMenuSelection", { bg = "#2F3540", fg = "#f0f8ff", bold = true })
end

local function fix_dap_highlights()
	vim.api.nvim_set_hl(0, "DapBreakpoint", { fg = "#e06c75", bg = "NONE", bold = true })
	vim.api.nvim_set_hl(0, "DapBreakpointCondition", { fg = "#e5c07b", bg = "NONE", italic = true })
	vim.api.nvim_set_hl(0, "DapBreakpointRejected", { fg = "#be5046", bg = "NONE" })
	vim.api.nvim_set_hl(0, "DapLogPoint", { fg = "#56b6c2", bg = "NONE" })
	vim.api.nvim_set_hl(0, "DapStopped", { fg = "#ffffff", bg = "#3e4452", bold = true })
	vim.api.nvim_set_hl(0, "DapStoppedLine", { bg = "#2f374f" })
	vim.api.nvim_set_hl(0, "CursorLine", { bg = "#2c313c" })
end

fix_blink_highlights()
fix_dap_highlights()
vim.api.nvim_create_autocmd("ColorScheme", {
	pattern = "*",
	callback = function()
		fix_blink_highlights()
		fix_dap_highlights()
	end,
})

vim.fn.sign_define("DapBreakpoint", { text = "‚óè", texthl = "DapBreakpoint", linehl = "", numhl = "" })
vim.fn.sign_define("DapStopped",
	{ text = "‚ûú", texthl = "DapStopped", linehl = "DapStoppedLine", numhl = "DapStoppedLine" })
vim.fn.sign_define("DapBreakpointCondition", { text = "‚óÜ", texthl = "DapBreakpointCondition" })
vim.fn.sign_define("DapLogPoint", { text = "üõà", texthl = "DapLogPoint" })
</file>

<file path="lua/config/dap.lua">
local dap = require("dap")
local wk  = require("which-key")
local fn  = vim.fn

require("mason").setup()
require("mason-nvim-dap").setup({
	ensure_installed       = { "codelldb", "java-debug-adapter" },
	automatic_installation = true,
})

pcall(function()
	require("config.rust") -- assumes rust.lua is at lua/rust.lua or otherwise in runtimepath as "rust"
end)

do
	local status_handler = vim.lsp.handlers["language/status"]
	vim.lsp.handlers["language/status"] = function(err, result, ctx, config)
		local client = ctx and ctx.client_id and vim.lsp.get_client_by_id(ctx.client_id)
		if client and client.name == "jdtls" and result and result.type == "ServiceReady" then
			local bufnr = ctx.bufnr or vim.api.nvim_get_current_buf()
			if not vim.api.nvim_buf_is_valid(bufnr) then
				return
			end
		end
		return status_handler(err, result, ctx, config)
	end
end

do
	local uri_mod = require("vim.uri")
	local orig_uri_from_bufnr = uri_mod.uri_from_bufnr
	local function safe_uri_from_bufnr(bufnr)
		if not vim.api.nvim_buf_is_valid(bufnr) then
			return ""
		end
		return orig_uri_from_bufnr(bufnr)
	end
	uri_mod.uri_from_bufnr = safe_uri_from_bufnr
	vim.uri_from_bufnr = safe_uri_from_bufnr
end


local function java_project()
	local root = require("jdtls.setup").find_root({ ".git", "mvnw", "gradlew", })
	if root and root ~= "" then
		return vim.fn.fnamemodify(root, ":t")
	end
	return vim.fn.fnamemodify(vim.fn.getcwd(), ":t")
end

dap.configurations.java = {
	{
		type        = "java",
		request     = "attach",
		name        = "Connect remote: 127.0.0.1:5005",
		hostName    = "127.0.0.1",
		port        = 5005,
		projectName = java_project(),
	},
}
-- dap.configurations.rust = {
-- 	{
-- 		name    = "Attach to Rust Process",
-- 		type    = "codelldb",
-- 		request = "attach",
-- 		pid     = function() return tonumber(fn.input("PID > ")) end,
-- 		program = function()
-- 			return fn.input("Path to executable > ", fn.getcwd() .. "/target/debug/", "file")
-- 		end,
-- 		cwd     = "${workspaceFolder}",
-- 	},
-- }

vim.api.nvim_create_autocmd("LspAttach", {
	callback = function(args)
		local client = vim.lsp.get_client_by_id(args.data.client_id)
		if client and client.name == "jdtls" then
			local jdtls = require("jdtls")
			jdtls.setup_dap({ hotcodereplace = "auto" })
			pcall(function()
				require("jdtls.dap").setup_dap_main_class_configs()
			end)
			local dap_ok, dap_mod = pcall(require, "dap")
			if dap_ok and dap_mod.providers and dap_mod.providers.configs then
				dap_mod.providers.configs["jdtls"] = nil
			end
		end
	end,
})

require("nvim-dap-virtual-text").setup()

do
	local ok, dapview = pcall(require, "dap-view")
	if ok then
		dapview.setup({ auto_toggle = true })
	end
end


wk.add({
	{ "<leader>d",  group = "Debug" },
	{ "<leader>db", dap.toggle_breakpoint, desc = "Toggle Breakpoint" },
	{
		"<leader>dc",
		function()
			local session = dap.session()
			if session then
				dap.terminate()
				local ok, dapview = pcall(require, "dap-view")
				if ok then dapview.close() end
				vim.schedule(function() vim.cmd("wincmd =") end)
			else
				dap.continue()
			end
		end,
		desc = "Start/Continue or Close Debug",
	},
	{ "<leader>di", dap.step_into, desc = "Step Into" },
	{ "<leader>do", dap.step_over, desc = "Step Over" },
	{ "<leader>du", dap.step_out,  desc = "Step Out" },
	{ "<leader>dr", dap.repl.open, desc = "Open REPL" },
	{ "<leader>dl", dap.run_last,  desc = "Run Last Debug Config" },
	{ "<leader>dT", dap.terminate, desc = "Terminate Session" },
	{
		"<leader>dQ",
		function()
			dap.terminate()
			local ok, dapview = pcall(require, "dap-view")
			if ok then dapview.close() end
			vim.schedule(function() vim.cmd("wincmd =") end)
		end,
		desc = "Terminate & Close UI",
	},
	{
		"<leader>dU",
		function()
			local ok, dapview = pcall(require, "dap-view")
			if ok then dapview.toggle() end
		end,
		desc = "Toggle DAP View",
	},
})
</file>

<file path="lua/config/java.lua">
local M            = {}

local mason_root   = vim.env.MASON or vim.fn.stdpath("data") .. "/mason"
local jdtls_pkg    = mason_root .. "/packages/jdtls"
local config_dir   = jdtls_pkg .. "/config_linux"
local launcher_jar = vim.fn.glob(jdtls_pkg .. "/plugins/org.eclipse.equinox.launcher_*.jar", false, true)[1]
local dbg_pkg      = mason_root .. "/packages/java-debug-adapter/extension/server"
local test_pkg     = mason_root .. "/packages/java-test/extension/server"

local function make_config()
	local root_dir = require("jdtls.setup").find_root({ ".git", "mvnw", "gradlew", })
	if not root_dir then
		vim.notify("jdtls: could not find project root; skipping start", vim.log.levels.WARN)
		return nil
	end

	local project_name  = vim.fn.fnamemodify(root_dir, ":p:h:t")
	local workspace_dir = vim.fn.stdpath("data") .. "/jdtls/workspace/" .. project_name

	assert(launcher_jar ~= "", "JDTLS launcher jar not found.")
	assert(vim.fn.isdirectory(config_dir) == 1, "JDTLS config directory not found: " .. config_dir)

	local bundles = {}
	local debug_bundles = vim.fn.glob(dbg_pkg .. "/com.microsoft.java.debug.plugin-*.jar", false, true)
	if type(debug_bundles) == "table" then
		for _, jar in ipairs(debug_bundles) do
			table.insert(bundles, jar)
		end
	elseif debug_bundles ~= "" then
		table.insert(bundles, debug_bundles)
	end
	local test_bundles = vim.fn.glob(test_pkg .. "/*.jar", false, true)
	if type(test_bundles) == "table" then
		for _, jar in ipairs(test_bundles) do
			table.insert(bundles, jar)
		end
	elseif test_bundles ~= "" then
		table.insert(bundles, test_bundles)
	end

	local config = {
		cmd = {
			"java",
			"-Declipse.application=org.eclipse.jdt.ls.core.id1",
			"-Dosgi.bundles.defaultStartLevel=4",
			"-Declipse.product=org.eclipse.jdt.ls.core.product",
			"-Dlog.protocol=true",
			"-Dlog.level=ALL",
			"-Xmx1g",
			"--add-modules=ALL-SYSTEM",
			"--add-opens", "java.base/java.util=ALL-UNNAMED",
			"--add-opens", "java.base/java.lang=ALL-UNNAMED",
			"-jar", launcher_jar,
			"-configuration", config_dir,
			"-data", workspace_dir,
		},
		root_dir = root_dir,
		settings = {
			java = {},
		},
		init_options = {
			bundles = bundles,
		},
	}

	return config
end

M.get_config = make_config

return M
</file>

<file path="lua/config/lazy.lua">
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
	local lazyrepo = "https://github.com/folke/lazy.nvim.git"
	local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
	if vim.v.shell_error ~= 0 then
		vim.api.nvim_echo({
			{ "Failed to clone lazy.nvim:\n", "ErrorMsg" },
			{ out, "WarningMsg" },
			{ "\nPress any key to exit..." },
		}, true, {})
		vim.fn.getchar()
		os.exit(1)
	end
end
vim.opt.rtp:prepend(lazypath)

require("lazy").setup({
	spec = {
		{ import = "plugins" },
		require("config.theme"),
	},
	defaults = {
		lazy = false,
		version = false,
	},
	checker = {
		enabled = false,
		notify = false,
		frequency = 3600,
	},
	performance = {
		rtp = {
			disabled_plugins = {
				"gzip",
				"matchit",
				"matchparen",
				"netrwPlugin",
				"tarPlugin",
				"tohtml",
				"zipPlugin",
			},
		},
	},
})
</file>

<file path="lua/config/mappings.lua">
local ok, wk = pcall(require, "which-key")

if not ok then
	return
end

vim.g.copilot_no_tab_map = true
vim.api.nvim_set_keymap("i", "<Right>", 'copilot#Accept("<CR>")', { expr = true, silent = true })
vim.keymap.set("i", "<Space>", "<Space>", { noremap = true, silent = true })

-- Window movement
wk.add({
	{ "<C-k>", "<C-w>k", desc = "Move to window above" },
	{ "<C-j>", "<C-w>j", desc = "Move to window below" },
	{ "<C-h>", "<C-w>h", desc = "Move to window left" },
	{ "<C-l>", "<C-w>l", desc = "Move to window right" },
}, { mode = "n" })

-- Edition
wk.add({
	{ "<C-a>", "ggVG", desc = "Select all" },
	{ "d", '"_d', desc = "Do not copy when deleting" },
	{ "D", '"_D', desc = "Do not copy when deleting" },
	{ "dd", '"_dd', desc = "Do not copy when deleting" },
	{ "c", '"_c', desc = "Do not copy when changing" },
	{ "C", '"_C', desc = "Do not copy when changing" },
	{ "cc", '"_cc', desc = "Do not copy when changing" },
	{ "H", "^", desc = "Move to first character of line" },
	{ "L", "$", desc = "Move to last character of line" },
})

-- Utils
wk.add({
	{ "<a-k>", ":m .-2<cr>==", desc = "Move line up" },
	{ "<a-j>", ":m .+1<cr>==", desc = "Move line down" },
	{ "<a-o>", "mao<ESC>`a", desc = "New line in normal mode" },
	{ "<a-O>", "maO<ESC>`a", desc = "New line before in normal mode" },
})

-- Scrolling and commenting
wk.add({
	{ "<S-j>", "5j", desc = "Scroll 5 lines down" },
	{ "<S-k>", "5k", desc = "Scroll 5 lines up" },
	{ ".", "<Plug>(comment_toggle_linewise_current)", desc = "Toggle line comment" },
})

-- Buffer management
wk.add({
	{ "<a-left>", "<cmd>BufferLineCyclePrev<cr>", desc = "Go previous buffer" },
	{ "<a-right>", "<cmd>BufferLineCycleNext<cr>", desc = "Go next buffer" },
	{ "<a-q>", "<cmd>Bdelete!<cr>", desc = "Close current buffer" },
	{ "<C-s>", "<cmd>wall<cr>", desc = "Save all" },
})

-- Folds
wk.add({
	{ "|", "za", desc = "Toggle folds" },
})

-- Find & Search
wk.add({
	{ "<leader>f", group = "Find & Search" },
	{ "<leader>fc", "<cmd>Telescope current_buffer_fuzzy_find<cr>", desc = "Search in current buffer" },
	{ "<leader>fa", "<cmd>Telescope grep_string<cr>", desc = "Search for word in system" },
	{ "<leader>fg", "<cmd>Telescope live_grep<cr>", desc = "Live grep in workspace" },
	-- { "<leader>fr", "<cmd>Telescope oldfiles<cr>", desc = "Recent files" },
	{ "<leader>fh", "<cmd>Telescope command_history<cr>", desc = "Command history" },
	-- { "<leader>fz", "<cmd>Telescope zoxide list<cr>", desc = "Recent directories" },
	{ "<leader>fb", "<cmd>Telescope buffers<cr>", desc = "Open buffers" },
	{ "<leader>ft", "<cmd>Telescope help_tags<cr>", desc = "Help tags" },
})

-- Views & Windows
wk.add({
	{ "<leader>v", group = "Views & Windows" },
	{
		"<leader>vf",
		function()
			Snacks.explorer()
		end,
		desc = "Toggle file tree view",
	},
	-- { "<S-F6>", "<Plug>(MultitermList)<Plug>", desc = "List terminals" },
	-- { "<C-F6>", "<Plug>(MultitermKillCurrent)<Plug>", desc = "Kill terminal" },
	{ "<leader>vm", "<cmd>Markview splitToggle<cr>", desc = "Toggle Markdown preview" },
	{ "<leader>vs", "<cmd>Split<cr>", desc = "Split Window" },
	{ "<leader>vq", "<cmd>q<cr>", desc = "Quit current Window" },
})

-- code
wk.add({
	{ "<leader>c", group = "Code & LSP" },
	{
		"<leader>ca",
		require("actions-preview").code_actions,
		desc = "Code Action",
	},
	{
		"<leader>cd",
		require("goto-preview").goto_preview_definition,
		desc = "Go to Definition",
	},
	{
		"<leader>cf",
		require("goto-preview").goto_preview_references,
		desc = "Find References",
	},
	{
		"<leader>ch",
		vim.lsp.buf.hover,
		desc = "Hover Documentation",
	},
	{
		"<leader>cc",
		"<cmd>lua require('conform').format({ async = true, lsp_fallback = true })<cr>",
		desc = "Format Code",
	},
	{
		"<leader>cr",
		vim.lsp.buf.rename,
		desc = "Rename Symbol",
	},
	{
		"<leader>cw",
		vim.lsp.buf.workspace_symbol,
		desc = "Workspace Symbols",
	},
})

-- Diagnostics
wk.add({
	{ "<leader>x", group = "Diagnostics" },
	{ "<leader>xn", vim.diagnostic.goto_next, desc = "Next Diagnostic" },
	{ "<leader>xp", vim.diagnostic.goto_prev, desc = "Previous Diagnostic" },
	{ "<leader>xq", vim.diagnostic.setqflist, desc = "Diagnostics to Quickfix" },
	{ "<leader>xl", vim.diagnostic.setloclist, desc = "Diagnostics to Location List" },
})

-- Git operations (unified group)
wk.add({
	{ "<leader>g", group = "Git" },
	{ "<leader>gg", "<cmd>LazyGit<cr>", desc = "LazyGit" },
	{ "<leader>gb", "<cmd>Telescope git_branches<cr>", desc = "Git Branches" },
	{ "<leader>gc", "<cmd>Telescope git_commits<cr>", desc = "Git Commits" },
	{ "<leader>gs", "<cmd>Telescope git_status<cr>", desc = "Git Status" },
	{ "<leader>gf", "<cmd>Telescope git_files<cr>", desc = "Git Files" },
})

-- Insert mode mappings
wk.add({
	mode = { "i" },
	{ "<a-b>", "<C-o>b", desc = "Move to previous word" },
	{ "<a-w>", "<C-o>w", desc = "Move to next word" },
	{ "<a-c>", '<C-o>"_ciw', desc = "Change word" },
	{ "<a-d>", '<C-o>"_diw', desc = "Delete word" },
	{ "<a-j>", "<ESC>:m .+1<cr>==gi", desc = "Move block down" },
	{ "<a-k>", "<ESC>:m .-2<cr>==gi", desc = "Move block up" },
})

-- Visual mode mappings
wk.add({
	mode = { "v" },
	{ "v", "^o$", desc = "Select current line" },
	{ "<", "<gv", desc = "Indent left" },
	{ ">", ">gv", desc = "Indent right" },
	{ "x", '"+d', desc = "Cut to system clipboard" },
	{ "y", '"+y', desc = "Copy to system clipboard" },
	{ "p", '"+p', desc = "Paste from system clipboard" },
	{ ".", "gc", desc = "Toggle block comment" },
	{ "<leader>ca", vim.lsp.buf.code_action, desc = "Code Action (Range)" },
})
</file>

<file path="lua/config/rust.lua">
local dap = require("dap")
local fn  = vim.fn

local function get_codelldb()
    if fn.executable("codelldb") == 1 then
        return "codelldb"
    end
    local mason_bin = fn.stdpath("data") .. "/mason/bin/codelldb"
    if fn.executable(mason_bin) == 1 then
        return mason_bin
    end
    vim.notify("[dap][rust] codelldb not found in PATH or mason bin; please install or adjust path.",
        vim.log.levels.WARN)
    return "codelldb" -- allow visible failure downstream
end

dap.adapters.codelldb = {
    type = "executable",
    command = get_codelldb(),
}

local function get_binary()
    local cwd = fn.getcwd()
    local metadata_cmd = { "cargo", "metadata", "--no-deps", "--format-version", "1" }
    local metadata_raw = fn.systemlist(metadata_cmd, cwd)
    if vim.v.shell_error ~= 0 then
        return nil, "cargo metadata failed: " .. table.concat(metadata_raw, "\n")
    end

    local ok, metadata = pcall(vim.fn.json_decode, table.concat(metadata_raw, "\n"))
    if not ok or type(metadata) ~= "table" then
        return nil, "failed to parse cargo metadata"
    end

    local chosen_package
    for _, pkg in ipairs(metadata.packages or {}) do
        local manifest_dir = vim.fn.fnamemodify(pkg.manifest_path or "", ":h")
        if vim.startswith(fn.getcwd(), manifest_dir) then
            chosen_package = pkg
            break
        end
    end
    if not chosen_package and metadata.packages and #metadata.packages > 0 then
        chosen_package = metadata.packages[1]
    end
    if not chosen_package then
        return nil, "no package found in cargo metadata"
    end

    local bin_target
    for _, target in ipairs(chosen_package.targets or {}) do
        for _, kind in ipairs(target.kind or {}) do
            if kind == "bin" then
                bin_target = target
                break
            end
        end
        if bin_target then break end
    end
    if not bin_target then
        return nil, "no binary target in package " .. (chosen_package.name or "<unknown>")
    end

    local target_dir = metadata.target_directory or (fn.getcwd() .. "/target")
    local exe_name = bin_target.name
    local candidate = target_dir .. "/debug/" .. exe_name
    return candidate, nil
end

local function resolve_bin()
    local cwd = fn.getcwd()
    local build_cmd = { "cargo", "build" }
    local build_output = fn.systemlist(build_cmd, cwd)
    if vim.v.shell_error ~= 0 then
        vim.notify("[dap][rust] cargo build failed:\n" .. table.concat(build_output, "\n"), vim.log.levels.ERROR)
        return nil
    end

    do
        local metadata_cmd = { "cargo", "metadata", "--no-deps", "--format-version", "1" }
        local metadata_raw = fn.systemlist(metadata_cmd, cwd)
        if vim.v.shell_error == 0 then
            local ok, metadata = pcall(vim.fn.json_decode, table.concat(metadata_raw, "\n"))
            if ok and type(metadata) == "table" then
                local chosen_package
                for _, pkg in ipairs(metadata.packages or {}) do
                    local manifest_dir = vim.fn.fnamemodify(pkg.manifest_path or "", ":h")
                    if vim.startswith(fn.getcwd(), manifest_dir) then
                        chosen_package = pkg
                        break
                    end
                end
                if not chosen_package and metadata.packages and #metadata.packages > 0 then
                    chosen_package = metadata.packages[1]
                end
                if chosen_package then
                    local target_dir = metadata.target_directory or (fn.getcwd() .. "/target")
                    local candidates = {}
                    for _, target in ipairs(chosen_package.targets or {}) do
                        local is_bin = false
                        for _, kind in ipairs(target.kind or {}) do
                            if kind == "bin" then
                                is_bin = true
                                break
                            end
                        end
                        if is_bin then
                            local path = target_dir .. "/debug/" .. target.name
                            if fn.filereadable(path) == 1 then
                                table.insert(candidates, path)
                            end
                        end
                    end
                    if #candidates == 1 then
                        return candidates[1]
                    elseif #candidates > 1 then
                        local opts = { "Select executable to debug:" }
                        for i, exe in ipairs(candidates) do
                            table.insert(opts, string.format("%d. %s", i, exe))
                        end
                        local choice = fn.inputlist(opts)
                        if choice >= 1 and choice <= #candidates then
                            return candidates[choice]
                        end
                        return candidates[1]
                    end
                end
            end
        end
    end

    local exe_path, err = get_binary()
    if exe_path and vim.fn.filereadable(exe_path) == 1 then
        return exe_path
    end

    if err then
        vim.notify("[dap][rust] auto-resolve binary failed: " .. err .. "; falling back to manual input",
            vim.log.levels.WARN)
    else
        vim.notify("[dap][rust] expected binary missing; falling back to manual input: " .. tostring(exe_path),
            vim.log.levels.WARN)
    end

    local default = cwd .. "/target/debug/"
    local explicit = fn.input("Path to executable (built): ", default, "file")
    if explicit == "" then
        vim.notify("[dap][rust] no executable path provided.", vim.log.levels.ERROR)
        return nil
    end
    return explicit
end


local function get_binaries()
    local bins = {}
    local cwd = fn.getcwd()
    local metadata_cmd = { "cargo", "metadata", "--no-deps", "--format-version", "1" }
    local metadata_raw = fn.systemlist(metadata_cmd, cwd)
    if vim.v.shell_error ~= 0 then
        return bins
    end
    local ok, metadata = pcall(vim.fn.json_decode, table.concat(metadata_raw, "\n"))
    if not ok or type(metadata) ~= "table" then
        return bins
    end
    local chosen_package
    for _, pkg in ipairs(metadata.packages or {}) do
        local manifest_dir = vim.fn.fnamemodify(pkg.manifest_path or "", ":h")
        if vim.startswith(cwd, manifest_dir) then
            chosen_package = pkg
            break
        end
    end
    if not chosen_package and metadata.packages and #metadata.packages > 0 then
        chosen_package = metadata.packages[1]
    end
    if not chosen_package then
        return bins
    end
    local target_dir = metadata.target_directory or (cwd .. "/target")
    for _, target in ipairs(chosen_package.targets or {}) do
        local is_bin = false
        for _, kind in ipairs(target.kind or {}) do
            if kind == "bin" then
                is_bin = true
                break
            end
        end
        if is_bin then
            local path = target_dir .. "/debug/" .. target.name
            if fn.filereadable(path) == 1 then
                table.insert(bins, { name = target.name, path = path })
            end
        end
    end
    return bins
end

local function make_launch_config(bin)
    return {
        name = "Launch: " .. bin.name,
        type = "codelldb",
        request = "launch",
        program = function()
            local cwd = fn.getcwd()
            local build_cmd = { "cargo", "build" }
            local build_output = fn.systemlist(build_cmd, cwd)
            if vim.v.shell_error ~= 0 then
                vim.notify("[dap][rust] cargo build failed:\n" .. table.concat(build_output, "\n"), vim.log.levels.ERROR)
                return nil
            end
            return bin.path
        end,
        cwd = "${workspaceFolder}",
        stopOnEntry = false,
        runInTerminal = false,
        env = {
            RUST_BACKTRACE = "1",
        },
        showDisassembly = "never",
        sourceLanguages = { "rust" },
    }
end

do
    local rust_configs = {}
    local bins = get_binaries()
    if #bins > 0 then
        for _, bin in ipairs(bins) do
            table.insert(rust_configs, make_launch_config(bin))
        end
    else
        table.insert(rust_configs, {
            name = "Launch: Current Project",
            type = "codelldb",
            request = "launch",
            program = function()
                local exe = resolve_bin()
                if not exe or exe == "" then
                    error("Failed to determine executable to launch.")
                end
                return exe
            end,
            cwd = "${workspaceFolder}",
            stopOnEntry = false,
            runInTerminal = false,
            env = {
                RUST_BACKTRACE = "1",
            },
            showDisassembly = "never",
            sourceLanguages = { "rust" },
        })
    end
    table.insert(rust_configs, {
        name = "Attach to Process (by PID)",
        type = "codelldb",
        request = "attach",
        pid = function()
            local input = fn.input("PID > ")
            return tonumber(input)
        end,
        program = function()
            local default = fn.getcwd() .. "/target/debug/"
            return fn.input("Path to executable (for symbol resolution): ", default, "file")
        end,
        cwd = "${workspaceFolder}",
        showDisassembly = "never",
        sourceLanguages = { "rust" },
    })
    table.insert(rust_configs, {
        name = "Attach to Process (by name)",
        type = "codelldb",
        request = "attach",
        pid = function()
            local default_name = vim.fn.fnamemodify(fn.getcwd(), ":t")
            local pname = fn.input("Process name to attach to: ", default_name)
            local matches = fn.systemlist({ "pgrep", "-f", pname })
            if #matches == 0 then
                vim.notify("[dap][rust] no process found matching: " .. pname, vim.log.levels.ERROR)
                return nil
            end
            return tonumber(matches[1])
        end,
        program = function()
            local default = fn.getcwd() .. "/target/debug/"
            return fn.input("Path to executable (for symbol resolution): ", default, "file")
        end,
        cwd = "${workspaceFolder}",
        showDisassembly = "never",
        sourceLanguages = { "rust" },
    })
    dap.configurations.rust = rust_configs
end

-- ===========================
-- LSP configuration 
-- ===========================
local M = {}

local function make_ra_config()
    local mason_root = vim.env.MASON or (vim.fn.stdpath("data") .. "/mason")
    local ra_bin = mason_root .. "/bin/rust-analyzer"
    if vim.fn.executable(ra_bin) ~= 1 then
        ra_bin = "rust-analyzer"
    end

    local util = require("lspconfig.util")
    local rooter = util.root_pattern("Cargo.toml", "rust-project.json", ".git")

    local settings = {
        ["rust-analyzer"] = {
            cargo = {
                allTargets = false,
                buildScripts = { enable = false },
            },
            check = {
                command = "check",
                allTargets = false,
            },
            procMacro = { enable = false },
            files = {
                watcher = "server",
                excludeDirs = { "target", ".git", ".cargo", ".rustup", "node_modules" },
            },
            diagnostics = {
                enable = true,
                experimental = { enable = false },
            },
            inlayHints = {
                typeHints = { enable = true },
                parameterHints = { enable = false },
                maxLength = 30,
            },
            completion = {
                autoimport = { enable = true },
            },
        },
    }

    local capabilities = vim.lsp.protocol.make_client_capabilities()
    pcall(function()
        capabilities = require("blink.cmp").get_lsp_capabilities(capabilities)
    end)

    return {
        cmd = { ra_bin },
        root_dir = function(fname)
            return rooter(fname) or vim.loop.cwd()
        end,
        settings = settings,
        capabilities = capabilities,
        flags = { debounce_text_changes = 150 },
    }
end

M.get_config = make_ra_config

return M
</file>

<file path="lua/config/theme.lua">
return {
  "sainnhe/sonokai",
  name     = "sonokai",
  lazy     = false,
  priority = 1000,
  config = function()

    vim.g.sonokai_style                  = "default"
    vim.g.sonokai_enable_italic          = 1
    vim.g.sonokai_transparent_background = 1

    vim.g.sonokai_colors_override = {
      bg0     = "#1c1c1c",
      bg2     = "#1c1c1c",
    }

    vim.cmd("colorscheme sonokai")

    require("notify").setup({
      background_colour = "#1c1c1c",
    })
    -- vim.api.nvim_set_hl(0, "NotifyBackground", { bg = "#1c1c1c" })
  end,
}
</file>

<file path="lua/plugins/autosplit.lua">
return {
    "yochem/autosplit.nvim",
    config = function()
        require('autosplit').setup({
            split = 'auto',
            min_win_width = 80
        })
    end,
}
</file>

<file path="lua/plugins/blink.lua">
return {
    "saghen/blink.cmp",
    dependencies = { "rafamadriz/friendly-snippets" },
    version = "1.*",
    opts = {
        keymap = {
            preset = "enter",

            -- ["<Up>"] = { "select_prev", "fallback" },
            -- ["<Down>"] = { "select_next", "fallback" },
            -- ["<Tab>"] = { "accept_and_enter", "fallback" },
            -- ["<CR>"] = { "accept", "fallback" },
            -- ["<S-d>"] = { "show_documentation", "hide_documentation", "fallback" },
            -- ["<S-k>"] = { "show_signature", "hide_signature", "fallback" },
        },

        appearance = {
            nerd_font_variant = "mono",
        },

        completion = { documentation = { auto_show = false } },

        sources = {
            default = { "lsp", "path", "snippets", "buffer" },
        },

        fuzzy = { implementation = "prefer_rust_with_warning" },
    },
    opts_extend = { "sources.default" },
}
</file>

<file path="lua/plugins/bufferline.lua">
return {
	"akinsho/bufferline.nvim",
	dependencies = { "echasnovski/mini.icons", "famiu/bufdelete.nvim" },
	config = function()
		require("bufferline").setup({
			options = {
				mode = "buffers",
				numbers = "none",
				close_command = "Bdelete! %d",
				right_mouse_command = "Bdelete! %d",
				left_mouse_command = "buffer %d",
				middle_mouse_command = nil,
				indicator = { icon = "| ", style = "none" },
				buffer_close_icon = "ÔÄç",
				modified_icon = "‚óè",
				close_icon = "ÔÄç",
				left_trunc_marker = "ÔÇ®",
				right_trunc_marker = "ÔÇ©",
				max_name_length = 18,
				max_prefix_length = 15,
				tab_size = 18,
				diagnostics = "nvim_lsp",
				diagnostics_update_in_insert = false,
				diagnostics_indicator = function(count)
					return "(" .. count .. ")"
				end,
				color_icons = true,
				show_buffer_icons = true,
				show_buffer_close_icons = true,
				show_close_icon = true,
				show_tab_indicators = true,
				persist_buffer_sort = true,
				separator_style = "thin",
				enforce_regular_tabs = false,
				always_show_bufferline = true,
				sort_by = "insert_after_current",
			},
			highlights = {
				buffer_selected = {
					bold = true,
					italic = false,
				},
				numbers_selected = {
					bold = true,
					italic = false,
				},
				close_button_selected = {},
				diagnostic_selected = {
					bold = true,
					italic = false,
				},
				hint_selected = {
					bold = true,
					italic = false,
				},
				hint_diagnostic_selected = {
					bold = true,
					italic = false,
				},
				info_selected = {
					bold = true,
					italic = false,
				},
				info_diagnostic_selected = {
					bold = true,
					italic = false,
				},
				warning_selected = {
					bold = true,
					italic = false,
				},
				warning_diagnostic_selected = {
					bold = true,
					italic = false,
				},
				error_selected = {
					bold = true,
					italic = false,
				},
				error_diagnostic_selected = {
					bold = true,
					italic = false,
				},
				duplicate_selected = {},
				duplicate_visible = {},
				duplicate = {},
				pick_selected = {
					bold = true,
					italic = false,
				},
				pick_visible = {
					bold = true,
					italic = false,
				},
				pick = {
					bold = true,
					italic = false,
				},
			},
		})
	end,
}
</file>

<file path="lua/plugins/conform.lua">
return {
	"stevearc/conform.nvim",
	opts = {
		formatters = {
			xmllint = {
				command = "xmllint",
				args = { "--format", "-" },
				stdin = true,
			},
			tidy = {
				command = "tidy",
				args = { "--tidy-mark", "no", "-quiet", "-indent", "-wrap", "0", "-indent-spaces", "4" },
				stdin = true,
			},
			google_java_format = {
				command = "google-java-format",
				args = { "-" },
				stdin = true,
			},
			rustfmt = {
				command = "rustfmt",
				args = { "--emit=stdout", "--edition=2024", "--config", "tab_spaces=4" },
				stdin = true,
			},
		},

		formatters_by_ft = {
			lua = { "stylua" },
			json = { "jq" },
			html = { "prettierd", "prettier", "tidy", stop_after_first = true },
			css = { "prettierd", "prettier", "tidy", stop_after_first = true },
			xhtml = { "xmllint", "tidy" },
			xml = { "xmllint" },
			xsd = { "xmllint" },
			javascript = { "prettierd", "prettier", stop_after_first = true },
			typescript = { "prettierd", "prettier", stop_after_first = true },
			java = { "google_java_format" },
			rust = { "rustfmt" },
			python = { "black", "isort" },
			c = { "clang-format" },
			cpp = { "clang-format" },
		},
	},
}
</file>

<file path="lua/plugins/dap-view.lua">
return {
	{
		"igorlfs/nvim-dap-view",
		event = "VeryLazy",
		opts  = {
			winbar = {
				show = true,
				sections = { "watches", "scopes", "exceptions", "breakpoints", "threads", "repl", "console" },
				default_section = "scopes",
			},
		}
	},
}
</file>

<file path="lua/plugins/dap.lua">
return {
  {
    "mfussenegger/nvim-dap",
    event        = "VeryLazy",
    dependencies = {
      "williamboman/mason.nvim",
      "jay-babu/mason-nvim-dap.nvim",
      "theHamsta/nvim-dap-virtual-text",
      "nvim-neotest/nvim-nio",
    },
    config = function()
      require("config.dap")
    end,
  },
}
</file>

<file path="lua/plugins/fff.lua">
return {
	"dmtrKovalenko/fff.nvim",
	build = "cargo build --release",
	keys = {
		{
			"<leader>ff",
			function()
				require("fff").toggle()
			end,
			desc = "Toggle FFF",
		},
	},
}
</file>

<file path="lua/plugins/goto_preview.lua">
local function in_preview_window()
	local win = vim.api.nvim_get_current_win()
	local ok, is_preview = pcall(vim.api.nvim_win_get_var, win, "is-goto-preview-window")
	return ok and is_preview == 1, win
end

return {
	"rmagatti/goto-preview",
	dependencies = { "rmagatti/logger.nvim" },
	event = "BufEnter",
	config = true,

	vim.keymap.set("n", "<C-CR>", function()
        local ok, win = in_preview_window()
		if ok then
            local buf = vim.api.nvim_win_get_buf(win)
			local file = vim.api.nvim_buf_get_name(buf)
			local pos = vim.api.nvim_win_get_cursor(win)
			require("goto-preview").close_all_win()
			vim.cmd("edit " .. vim.fn.fnameescape(file))
			vim.api.nvim_win_set_cursor(0, pos)
		end
	end, { desc = "Promote preview window to real buffer", silent = true }),

	vim.keymap.set("n", "q", function()
        local ok = in_preview_window()
		if ok then
			require("goto-preview").close_all_win()
		end
	end, { desc = "Close preview window", silent = true }),
}
</file>

<file path="lua/plugins/icons.lua">
return {
    "echasnovski/mini.icons",
    lazy = true,
    opts = {
        file = {
            [".keep"] = { glyph = "Û∞ä¢", hl = "MiniIconsGrey" },
            ["devcontainer.json"] = { glyph = "Û∞°®", hl = "MiniIconsAzure" },
        },
        filetype = {
            dotenv = { glyph = "Û∞ô™", hl = "MiniIconsYellow" },
        },
    },
    init = function()
        package.preload["nvim-web-devicons"] = function()
            require("mini.icons").mock_nvim_web_devicons()
            return package.loaded["nvim-web-devicons"]
        end
    end,
}
</file>

<file path="lua/plugins/lazygit.lua">
return {
    "kdheepak/lazygit.nvim",
    lazy = true,
    dependencies = {
        "nvim-lua/plenary.nvim",
    },
    cmd = {
        "LazyGit",
        "LazyGitConfig",
        "LazyGitCurrentFile",
        "LazyGitFilter",
        "LazyGitFilterCurrentFile",
    },
}
</file>

<file path="lua/plugins/lualine.lua">
return {
    "nvim-lualine/lualine.nvim",
    config = function()
        require("lualine").setup({
            options = {
                icons_enabled = true,
                theme = "sonokai",
                disabled_filetypes = {},
                always_divide_middle = true,
                globalstatus = true,
            },
        })
    end,
}
</file>

<file path="lua/plugins/markdown.lua">
return {
	"OXY2DEV/markview.nvim",
	lazy = false,
	dependencies = {
		"nvim-treesitter/nvim-treesitter",
		"echasnovski/mini.icons",
	},
	config = function()
		local presets = require("markview.presets")
		require("markview").setup({
			experimental = {
				check_rtp = false,
			},
			markdown = {
				headings = presets.headings.glow_center,
				horizontal_rules = presets.horizontal_rules.dotted,
				code_blocks = {
					border_hl = "MarkviewCode",
					info_hl = "MarkviewCodeInfo",
					language_direction = "right",
					min_width = 60,
					pad_amount = 3,
					pad_char = " ",
					sign = true,
					style = "language",
				},
			},
			markdown_inline = {
				checkboxes = presets.checkboxes.nerd,
			},
			preview = {
				enable = false,
				filetypes = { "md", "rmd", "quarto" },
			},
		})
	end,
}
</file>

<file path="lua/plugins/mason.lua">
return {
	{
		"williamboman/mason.nvim",
		config = function()
			require("mason").setup({
				ui = {
					border = "rounded",
					icons = {
						package_installed = "‚úì",
						package_pending = "‚ûú",
						package_uninstalled = "‚úó",
					},
				},
			})
		end,
	},
	{
		"williamboman/mason-lspconfig.nvim",
		config = function()
			require("mason-lspconfig").setup({
				ensure_installed = {
					"rust_analyzer",
					"lua_ls",
					"bashls",
					"clangd",
					"jdtls",
					"pyright",
					"ts_ls",
				},
				automatic_installation = true,
				automatic_enable = {
					exclude = { "jdtls", "rust_analyzer" }, 
				},

			})
		end,
	}
}
</file>

<file path="lua/plugins/multiterm.lua">
return {
	"imranzero/multiterm.nvim",
	event = "VeryLazy",
	config = function()
		require("multiterm").setup({
			vim.keymap.set({ "n", "v", "i", "t" }, "<F6>", "<Plug>(Multiterm)",
				{ silent = true, desc = "Toggle Multiterm" }),
			vim.keymap.set({ "n", "v", "i", "t" }, "<leader><F6>", "<Plug>(MultitermList)",
				{ silent = true, desc = "List Multiterm" })


		})
	end,

	-- config = function()
	-- 	require("multiterm").setup({})
	--
	-- 	local function toggle_term(tag)
	-- 		if vim.fn.mode() == "t" then
	-- 			vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<C-\\><C-n>", true, false, true), "n", false)
	-- 		end
	-- 		vim.cmd(tag .. "Multiterm")
	-- 	end
	--
	-- 	local function f6_handler()
	-- 		local mode = vim.fn.mode()
	-- 		local buftype = vim.bo.buftype
	--
	-- 		if mode == "t" or buftype == "terminal" then
	-- 			if mode == "t" then
	-- 				vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<C-\\><C-n>", true, false, true), "n", false)
	-- 			end
	-- 			vim.cmd("Multiterm")
	-- 			return
	-- 		end
	--
	-- 		local c = vim.fn.getchar()
	-- 		local k = vim.fn.nr2char(c)
	--
	-- 		if k:match("[1-9]") then
	-- 			toggle_term(k)
	-- 		else
	-- 			toggle_term("1")
	-- 		end
	-- 	end
	--
	-- 	vim.keymap.set({ "n", "t", "i", "v" }, "<F6>", f6_handler, { desc = "F6 (+1-9) Toggle terminal" })
	-- end,
}
</file>

<file path="lua/plugins/no_conf.lua">
return {
	"j-hui/fidget.nvim",
	"boltlessengineer/sense.nvim",
	"windwp/nvim-autopairs",
	"mg979/vim-visual-multi",
	"sitiom/nvim-numbertoggle",
	"github/copilot.vim",
	"ray-x/lsp_signature.nvim",
	"lambdalisue/suda.vim",
	"folke/todo-comments.nvim",
	"aznhe21/actions-preview.nvim",
	"numToStr/Comment.nvim",
	"kevinhwang91/nvim-bqf",
	"neovim/nvim-lspconfig",
	"mfussenegger/nvim-jdtls",
}
</file>

<file path="lua/plugins/noice.lua">
return {
    "folke/noice.nvim",
    event = "VeryLazy",
    dependencies = {
        "MunifTanjim/nui.nvim",
        "rcarriga/nvim-notify",
    },
    config = function()
        require("noice").setup({
            lsp = {
                override = {
                    ["vim.lsp.util.convert_input_to_markdown_lines"] = true,
                    ["vim.lsp.util.stylize_markdown"] = true,
                    ["cmp.entry.get_documentation"] = true,
                },
            },
            presets = {
                bottom_search = true,
                command_palette = true,
                long_message_to_split = true,
                inc_rename = false,
                lsp_doc_border = false,
            },
        })
    end,
}
</file>

<file path="lua/plugins/snacks.lua">
return {
  "folke/snacks.nvim",
  priority = 1000,
  lazy = false,
  opts = {
    animate = { enabled = true },
    bigfile = { enabled = true },
    bufdelete = { enabled = true },
    dashboard = { enabled = true },
    debug = { enabled = true },
    dim = { enabled = true },
    explorer = { enabled = true },
    git = { enabled = true },
    gitbrowse = { enabled = false },
    image = { enabled = true },
    indent = { enabled = false },
    input = { enabled = true },
    layout = { enabled = true },
    lazygit = { enabled = false },
    notifier = { enabled = false },
    notify = { enabled = false },
    picker = { enabled = true },
    profiler = { enabled = true },
    quickfile = { enabled = false },
    rename = { enabled = true },
    scope = { enabled = true },
    scratch = { enabled = false },
    scroll = { enabled = true },
    statuscolumn = { enabled = false },
    terminal = { enabled = false },
    toggle = { enabled = true },
    util = { enabled = true },
    win = { enabled = true },
    words = { enabled = true },
    zen = { enabled = false },
  },
}
</file>

<file path="lua/plugins/telescope.lua">
return {
	"nvim-telescope/telescope.nvim",
	tag = "0.1.8",
	dependencies = { "nvim-lua/plenary.nvim" },
}
</file>

<file path="lua/plugins/treesitter.lua">
return {
    "nvim-treesitter/nvim-treesitter",
    branch = "master",
    build = "TSUpdate",
    config = function()
        require("nvim-treesitter.configs").setup({
            ensure_installed = {
                "c", "lua", "vim", "vimdoc", "query",
                "markdown", "markdown_inline",
                "bash", "regex", "rust", "python",
                "javascript", "typescript", "java",
                "html", "css", "json", "rust",
            },
            ignore_install = {},
            modules = {},
            sync_install = false,
            parser_install_dir = nil,
            auto_install = true,
            highlight = {
                enable = true,
                additional_vim_regex_highlighting = false,
            },
            indent = {
                enable = true,
            },
        })
    end,
}
</file>

<file path="lua/plugins/urlpreview.lua">
return {
    "wurli/urlpreview.nvim",
    opts = {
        auto_preview = true,
        max_window_width = 100,
        hl_group_title = "@markup.heading",
        hl_group_description = "@markup.quote",
        hl_group_url = "Underlined",
        window_border = "none"
    }
}
</file>

<file path="lua/plugins/which_key.lua">
return {
	"folke/which-key.nvim",
	dependencies = {
		"echasnovski/mini.icons",
	},
	event = "VeryLazy",
	config = function()
		local wk = require("which-key")

		wk.setup({
			preset = "modern",
			icons = {
				breadcrumb = "¬ª",
				separator = "‚Üí",
				group = "",
				ellipsis = "‚Ä¶",
				mappings = true,
			},
			win = {
				border = "rounded",
				padding = { 1, 2 },
				title = true,
				title_pos = "center",
				zindex = 1000,
				wo = {
					winblend = 10,
				},
			},
			layout = {
				height = { min = 4, max = 25 },
				width = { min = 20, max = 50 },
				spacing = 3,
				align = "left",
			},
			keys = {
				scroll_down = "<c-d>",
				scroll_up = "<c-u>",
			},
			sort = { "local", "order", "group", "alphanum", "mod" },
			expand = 0,
			replace = {
				["<space>"] = "SPC",
				["<cr>"] = "RET",
				["<tab>"] = "TAB",
				["<leader>"] = "SPC",
			},
		})
	end,
}
</file>

<file path="scripts/nvid_helper.sh">
#!/usr/bin/env bash

# This script is meant to run in the background (detached).
# 1. It launches Neovide, passing along any arguments.
# 2. When Neovide closes, it opens a new Kitty in the saved directory.

saved_dir="$1"
shift  

neovide "$@"

kitty --directory "$saved_dir"
</file>

<file path="scripts/nvid_launcher.sh">
#!/usr/bin/env bash

# This script will:
#   - Use the current directory if no arguments are passed
#   - Resolve the directory via zoxide if a partial path is provided
#   - Allow explicit paths or arguments
#   - Start the helper script in the background (with the resolved directory and arguments)
#   - Kill the active Kitty window (or terminal) via hyprctl

if [[ -z "$1" ]]; then
    saved_dir="$PWD"
    args=(".")
else
    if [[ -d "$PWD/$1" ]]; then
        # Check if the folder exists in the current directory
        saved_dir="$PWD/$1"
        args=("$saved_dir")
    elif zoxide query "$1" &>/dev/null; then
        # Resolve via zoxide
        saved_dir=$(zoxide query "$1")
        args=("$saved_dir")
    elif [[ -d "$1" ]]; then
        # If the input is a valid directory
        saved_dir="$1"
        args=("$saved_dir")
    elif [[ -f "$1" ]]; then
        # If the input is a file, use its parent directory
        saved_dir=$(dirname "$(realpath "$1")")
        args=("${1##*/}") # Extract the filename as an argument
    else
        # Fallback to current directory and treat input as argument
        saved_dir="$PWD"
        args=("$@")
    fi

    if [[ -d "$saved_dir" && -z "${args[*]}" ]]; then
        args=("${@:2}")
    fi
fi

~/.config/nvim/scripts/nvid_helper.sh "$saved_dir" "${args[@]}" &

TERMINAL_PID=$(hyprctl activewindow | grep "pid:" | awk '{print $2}')

if [[ -n "$TERMINAL_PID" ]]; then
    kill "$TERMINAL_PID"
else
    echo "No terminal window found to close."
fi
</file>

<file path="init.lua">
vim.g.mapleader = " "
vim.g.maplocalleader = " "

require("config.lazy")
require("config.mappings")
require("config.autocmds")

local options = {
	number = true,
	relativenumber = true,
	clipboard = "unnamed,unnamedplus",
	mouse = "a",
	undodir = "/tmp/.nvimdid",
	undofile = true,
	confirm = true,
    signcolumn = "yes:1",
}



for key, value in pairs(options) do
	vim.o[key] = value
end
</file>

<file path="lazy-lock.json">
{
  "Comment.nvim": { "branch": "master", "commit": "e30b7f2008e52442154b66f7c519bfd2f1e32acb" },
  "actions-preview.nvim": { "branch": "master", "commit": "36513ad213855d497b7dd3391a24d1d75d58e36f" },
  "autosplit.nvim": { "branch": "main", "commit": "d98e381d5e436382c575faeeafc4f41c9c263a03" },
  "blink.cmp": { "branch": "main", "commit": "bae4bae0eedd1fa55f34b685862e94a222d5c6f8" },
  "bufdelete.nvim": { "branch": "master", "commit": "f6bcea78afb3060b198125256f897040538bcb81" },
  "bufferline.nvim": { "branch": "main", "commit": "655133c3b4c3e5e05ec549b9f8cc2894ac6f51b3" },
  "conform.nvim": { "branch": "master", "commit": "973f3cb73887d510321653044791d7937c7ec0fa" },
  "copilot.vim": { "branch": "release", "commit": "51f80c0ed4f70d1c7e8c0ff11a792a9d84502c03" },
  "fff.nvim": { "branch": "main", "commit": "76628e7a4872af3360a09d9755588d7f72ec5ca7" },
  "fidget.nvim": { "branch": "main", "commit": "4ec7bed6c86b671ddde03ca1b227343cfa3e65fa" },
  "friendly-snippets": { "branch": "main", "commit": "572f5660cf05f8cd8834e096d7b4c921ba18e175" },
  "goto-preview": { "branch": "main", "commit": "d1faf6ea992b5bcaaaf2c682e1aba3131a01143e" },
  "hererocks": { "branch": "master", "commit": "f4cc0b16619b9d9d59c92636c5b5e7c06dc7c082" },
  "lazy.nvim": { "branch": "main", "commit": "6c3bda4aca61a13a9c63f1c1d1b16b9d3be90d7a" },
  "lazygit.nvim": { "branch": "main", "commit": "cdd3527e251f96eb0527162b156ad839286fcd97" },
  "logger.nvim": { "branch": "main", "commit": "63dd10c9b9a159fd6cfe08435d9606384ff103c5" },
  "lsp_signature.nvim": { "branch": "master", "commit": "d9c39937e4e0977357530e988aa8940078bb231f" },
  "lualine.nvim": { "branch": "master", "commit": "a94fc68960665e54408fe37dcf573193c4ce82c9" },
  "markview.nvim": { "branch": "main", "commit": "ec33f2aa333ca1d76f51847922578434d7aeadf7" },
  "mason-lspconfig.nvim": { "branch": "main", "commit": "f2fa60409630ec2d24acf84494fb55e1d28d593c" },
  "mason-nvim-dap.nvim": { "branch": "main", "commit": "86389a3dd687cfaa647b6f44731e492970034baa" },
  "mason.nvim": { "branch": "main", "commit": "3671ab0d40aa5bd24b1686562bd0a23391ecf76a" },
  "mini.icons": { "branch": "main", "commit": "b8f6fa6f5a3fd0c56936252edcd691184e5aac0c" },
  "multiterm.nvim": { "branch": "master", "commit": "2dfb961163691d78663042c0a43280ee1ff52d3a" },
  "noice.nvim": { "branch": "main", "commit": "0427460c2d7f673ad60eb02b35f5e9926cf67c59" },
  "nui.nvim": { "branch": "main", "commit": "de740991c12411b663994b2860f1a4fd0937c130" },
  "nvim-autopairs": { "branch": "master", "commit": "23320e75953ac82e559c610bec5a90d9c6dfa743" },
  "nvim-bqf": { "branch": "main", "commit": "dd17c73912487dccb372deff85d4262d2b89bc2b" },
  "nvim-dap": { "branch": "master", "commit": "5dd4d50f2e6a2eaf9e57fad023d294ef371bda35" },
  "nvim-dap-view": { "branch": "main", "commit": "143411d3e5d76814345030d7029af935afc7116d" },
  "nvim-dap-virtual-text": { "branch": "master", "commit": "fbdb48c2ed45f4a8293d0d483f7730d24467ccb6" },
  "nvim-jdtls": { "branch": "master", "commit": "4d77ff02063cf88963d5cf10683ab1fd15d072de" },
  "nvim-lspconfig": { "branch": "master", "commit": "3db16ceeea947517f0dc1404c24dcb5ab0c91d26" },
  "nvim-nio": { "branch": "master", "commit": "21f5324bfac14e22ba26553caf69ec76ae8a7662" },
  "nvim-notify": { "branch": "master", "commit": "397c7c1184745fca649e5104de659e6392ef5a4d" },
  "nvim-numbertoggle": { "branch": "main", "commit": "4b898b84d6f31f76bd563330d76177d5eb299efa" },
  "nvim-treesitter": { "branch": "master", "commit": "42fc28ba918343ebfd5565147a42a26580579482" },
  "plenary.nvim": { "branch": "master", "commit": "b9fd5226c2f76c951fc8ed5923d85e4de065e509" },
  "sense.nvim": { "branch": "main", "commit": "74e61f251fffc64c4f29160569ccde087316b798" },
  "snacks.nvim": { "branch": "main", "commit": "bc0630e43be5699bb94dadc302c0d21615421d93" },
  "sonokai": { "branch": "master", "commit": "5baf26496047788dc000e9287e5ceb7420b2f42e" },
  "suda.vim": { "branch": "master", "commit": "9adda7d195222d4e2854efb2a88005a120296c47" },
  "telescope.nvim": { "branch": "master", "commit": "a0bbec21143c7bc5f8bb02e0005fa0b982edc026" },
  "todo-comments.nvim": { "branch": "main", "commit": "304a8d204ee787d2544d8bc23cd38d2f929e7cc5" },
  "urlpreview.nvim": { "branch": "main", "commit": "c8a0eca1c359fbb1fd189adaea4f359ea451f57b" },
  "vim-visual-multi": { "branch": "master", "commit": "a6975e7c1ee157615bbc80fc25e4392f71c344d4" },
  "which-key.nvim": { "branch": "main", "commit": "370ec46f710e058c9c1646273e6b225acf47cbed" }
}
</file>

</files>
